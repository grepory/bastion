The bastion and the opsee control plane communicate via short json messages exchanged over a persistent TLS socket.  


Server Commands
=======================
These are commands only the server is allowed to issue down to the bastion.

-> {"cmd":"shutdown"}

{"reply":"ok"} <-

This commands the bastion program to completely shutdown the instance on which it is running.

-> {"cmd":"backoff", "timeout":60}

{"reply":"ok"} <-

This command tells the bastion host to disconnect for a set period of time before reconnecting.  Timeout is specified in seconds.

-> {"cmd":"redirect", "host":"_.opsee.co"}

{"reply":"ok"} <-

Tells the bastion host to disconnect from the current server and reconnect to the one named.

-> {"cmd":"discovery"}

{"reply":
	{
		"totalInstances":10, 
		"unmonitoredInstances":[instance obj, ...], 
		"securityGroups":[sg obj, ...],
		"autoscaleGroups":[asg obj, ...]
	}} <-

This command requests a dump of the discovery table, a listing of the resources that have been found in the
environment and are not currently being monitored.

-> {"cmd":"healthcheck", "definition":
	{
		"checkId":"1234", 
		"groupType":"asg", 
		"groupId":"sdfsdfdf",
		"protocol":"tcp",
		"port":80,
		"minHosts":2,
		"timeout":30,
		"interval":60
	}}

{"reply":"ok"} <-

This command pushes down a health check definition to the bastion.  If a health check already exists for the given ID, then it is replaced.  Otherwise a new health check is started.

-> {"cmd":"delete","checks":[check id, ...]}

{"reply":"ok"} <-

Tells the bastion to delete the identified checks.  If checks is "all" instead of a list then all of the checks are deleted.

-> {"cmd":"checks"}

{"reply":"ok","checks":[health check obj, ...]} <-

Asks the bastion to dump its current set of health checks, mainly for debugging.

-> {"cmd":"disable","checks":[check id, ...],("timeout":60)}

{"reply":"ok"} <-

Asks the bastion to disable a set of health checks.  If the timeout is set then the disablement will automatically expire after that number of seconds.  If, instead of a list, checks is "all" then everything gets disabled.

-> {"cmd":"enable","checks":[check id, ...]}

{"reply":"ok"} <-

Asks the bastion to enable a set of health checks.  Same check id resolution as above.

Bastion Commands
=====================
These are commands that only the bastion may send up to the server.

{"cmd":"connected", "sent":ts, "host":
	{
		"hostname":"",
		"ip":"",
		"instanceId":"",
		"imageId":"",
		"region":"",
		"az":""
	}} <-

-> {"reply":"ok" | "blocked" | "backoff","timeout":60, "redirect","host":"___.opsee.co"}

The connected command sends up metadata about the instance on which it is running.  The sent field is a long epoch timestamp (nanoseconds since the epoch).  The server can either tell the bastion host that it is blocked, which will cause it to shut down completely, or that it must back off for the given number of seconds.

{"cmd":"discovery","discovery":discovery obj} <-

-> {"reply":"ok"}

The bastion periodically scans for hosts entering and leaving its reachable network.  Any new and unmonitored hosts, groups, etc will result in a discovery message in real time.

{"cmd":"results","results":[check results obj, ...]} <-

-> {"reply":"ok"}

The bastion host will periodically send up the successful results of any scans that have run since the last time results were sent.  The reply here is explicitly telling the bastion that the results have been written to durable storage and are ok for the bastion to forget.

{"cmd":"alert","service":"checkName","results":[check results obj, ...],"state":("down" | "flapping")} <-

-> {"reply":("ok" | "escalate")}

When a service violates its threshold (drops below minHosts for a period of time, or starts flapping between up and down) the bastion will immediately send an alert event to the server.  If the event gets delivered to the server, however for some reason the server feels that the event cannot be forwarded to the user, it will tell the bastion agent to escalate the issue.  This could mean different things depending on context, but essentially the bastion will attempt to deliver the message via a means other than the opsee backend.