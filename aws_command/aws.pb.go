// Code generated by protoc-gen-go.
// source: proto/aws.proto
// DO NOT EDIT!

/*
Package aws_command is a generated protocol buffer package.

It is generated from these files:
	proto/aws.proto

It has these top-level messages:
	StopInstancesRequest
	StopInstancesResult
	StartInstancesRequest
	InstanceState
	InstanceStateChange
	StartInstancesResult
	RebootInstancesRequest
	RebootInstancesResult
*/
package aws_command

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type StopInstancesRequest struct {
	DryRun      bool     `protobuf:"varint,1,opt,name=dryRun" json:"dryRun,omitempty"`
	Force       bool     `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
	InstanceIds []string `protobuf:"bytes,3,rep,name=InstanceIds" json:"InstanceIds,omitempty"`
}

func (m *StopInstancesRequest) Reset()                    { *m = StopInstancesRequest{} }
func (m *StopInstancesRequest) String() string            { return proto.CompactTextString(m) }
func (*StopInstancesRequest) ProtoMessage()               {}
func (*StopInstancesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type StopInstancesResult struct {
	StoppingInstances []*InstanceStateChange `protobuf:"bytes,1,rep,name=StoppingInstances" json:"StoppingInstances,omitempty"`
}

func (m *StopInstancesResult) Reset()                    { *m = StopInstancesResult{} }
func (m *StopInstancesResult) String() string            { return proto.CompactTextString(m) }
func (*StopInstancesResult) ProtoMessage()               {}
func (*StopInstancesResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StopInstancesResult) GetStoppingInstances() []*InstanceStateChange {
	if m != nil {
		return m.StoppingInstances
	}
	return nil
}

type StartInstancesRequest struct {
	AdditionalInfo string   `protobuf:"bytes,1,opt,name=additionalInfo" json:"additionalInfo,omitempty"`
	DryRun         bool     `protobuf:"varint,2,opt,name=dryRun" json:"dryRun,omitempty"`
	InstanceIds    []string `protobuf:"bytes,3,rep,name=InstanceIds" json:"InstanceIds,omitempty"`
}

func (m *StartInstancesRequest) Reset()                    { *m = StartInstancesRequest{} }
func (m *StartInstancesRequest) String() string            { return proto.CompactTextString(m) }
func (*StartInstancesRequest) ProtoMessage()               {}
func (*StartInstancesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type InstanceState struct {
	Code int64  `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *InstanceState) Reset()                    { *m = InstanceState{} }
func (m *InstanceState) String() string            { return proto.CompactTextString(m) }
func (*InstanceState) ProtoMessage()               {}
func (*InstanceState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type InstanceStateChange struct {
	InstanceId    string         `protobuf:"bytes,1,opt,name=instanceId" json:"instanceId,omitempty"`
	CurrentState  *InstanceState `protobuf:"bytes,2,opt,name=currentState" json:"currentState,omitempty"`
	PreviousState *InstanceState `protobuf:"bytes,3,opt,name=previousState" json:"previousState,omitempty"`
}

func (m *InstanceStateChange) Reset()                    { *m = InstanceStateChange{} }
func (m *InstanceStateChange) String() string            { return proto.CompactTextString(m) }
func (*InstanceStateChange) ProtoMessage()               {}
func (*InstanceStateChange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InstanceStateChange) GetCurrentState() *InstanceState {
	if m != nil {
		return m.CurrentState
	}
	return nil
}

func (m *InstanceStateChange) GetPreviousState() *InstanceState {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

type StartInstancesResult struct {
	StartingInstances []*InstanceStateChange `protobuf:"bytes,1,rep,name=StartingInstances" json:"StartingInstances,omitempty"`
}

func (m *StartInstancesResult) Reset()                    { *m = StartInstancesResult{} }
func (m *StartInstancesResult) String() string            { return proto.CompactTextString(m) }
func (*StartInstancesResult) ProtoMessage()               {}
func (*StartInstancesResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *StartInstancesResult) GetStartingInstances() []*InstanceStateChange {
	if m != nil {
		return m.StartingInstances
	}
	return nil
}

type RebootInstancesRequest struct {
	DryRun      bool     `protobuf:"varint,1,opt,name=dryRun" json:"dryRun,omitempty"`
	InstanceIds []string `protobuf:"bytes,2,rep,name=InstanceIds" json:"InstanceIds,omitempty"`
}

func (m *RebootInstancesRequest) Reset()                    { *m = RebootInstancesRequest{} }
func (m *RebootInstancesRequest) String() string            { return proto.CompactTextString(m) }
func (*RebootInstancesRequest) ProtoMessage()               {}
func (*RebootInstancesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// ec2.RebootInstancesOutput is just an empty struct, so just return whether or not the command executed in (err)
type RebootInstancesResult struct {
	Err string `protobuf:"bytes,1,opt,name=err" json:"err,omitempty"`
}

func (m *RebootInstancesResult) Reset()                    { *m = RebootInstancesResult{} }
func (m *RebootInstancesResult) String() string            { return proto.CompactTextString(m) }
func (*RebootInstancesResult) ProtoMessage()               {}
func (*RebootInstancesResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

var E_IsRequired = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         60000,
	Name:          "aws_command.is_required",
	Tag:           "varint,60000,opt,name=is_required",
}

var E_EnumName = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.EnumValueOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         51234,
	Name:          "aws_command.enum_name",
	Tag:           "bytes,51234,opt,name=enum_name",
}

func init() {
	proto.RegisterType((*StopInstancesRequest)(nil), "aws_command.StopInstancesRequest")
	proto.RegisterType((*StopInstancesResult)(nil), "aws_command.StopInstancesResult")
	proto.RegisterType((*StartInstancesRequest)(nil), "aws_command.StartInstancesRequest")
	proto.RegisterType((*InstanceState)(nil), "aws_command.InstanceState")
	proto.RegisterType((*InstanceStateChange)(nil), "aws_command.InstanceStateChange")
	proto.RegisterType((*StartInstancesResult)(nil), "aws_command.StartInstancesResult")
	proto.RegisterType((*RebootInstancesRequest)(nil), "aws_command.RebootInstancesRequest")
	proto.RegisterType((*RebootInstancesResult)(nil), "aws_command.RebootInstancesResult")
	proto.RegisterExtension(E_IsRequired)
	proto.RegisterExtension(E_EnumName)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Ec2 service

type Ec2Client interface {
	StartInstances(ctx context.Context, in *StartInstancesRequest, opts ...grpc.CallOption) (*StartInstancesResult, error)
	StopInstances(ctx context.Context, in *StopInstancesRequest, opts ...grpc.CallOption) (*StopInstancesResult, error)
	RebootInstances(ctx context.Context, in *RebootInstancesRequest, opts ...grpc.CallOption) (*RebootInstancesResult, error)
}

type ec2Client struct {
	cc *grpc.ClientConn
}

func NewEc2Client(cc *grpc.ClientConn) Ec2Client {
	return &ec2Client{cc}
}

func (c *ec2Client) StartInstances(ctx context.Context, in *StartInstancesRequest, opts ...grpc.CallOption) (*StartInstancesResult, error) {
	out := new(StartInstancesResult)
	err := grpc.Invoke(ctx, "/aws_command.ec2/StartInstances", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ec2Client) StopInstances(ctx context.Context, in *StopInstancesRequest, opts ...grpc.CallOption) (*StopInstancesResult, error) {
	out := new(StopInstancesResult)
	err := grpc.Invoke(ctx, "/aws_command.ec2/StopInstances", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ec2Client) RebootInstances(ctx context.Context, in *RebootInstancesRequest, opts ...grpc.CallOption) (*RebootInstancesResult, error) {
	out := new(RebootInstancesResult)
	err := grpc.Invoke(ctx, "/aws_command.ec2/RebootInstances", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ec2 service

type Ec2Server interface {
	StartInstances(context.Context, *StartInstancesRequest) (*StartInstancesResult, error)
	StopInstances(context.Context, *StopInstancesRequest) (*StopInstancesResult, error)
	RebootInstances(context.Context, *RebootInstancesRequest) (*RebootInstancesResult, error)
}

func RegisterEc2Server(s *grpc.Server, srv Ec2Server) {
	s.RegisterService(&_Ec2_serviceDesc, srv)
}

func _Ec2_StartInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StartInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(Ec2Server).StartInstances(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Ec2_StopInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StopInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(Ec2Server).StopInstances(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Ec2_RebootInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RebootInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(Ec2Server).RebootInstances(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Ec2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aws_command.ec2",
	HandlerType: (*Ec2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartInstances",
			Handler:    _Ec2_StartInstances_Handler,
		},
		{
			MethodName: "StopInstances",
			Handler:    _Ec2_StopInstances_Handler,
		},
		{
			MethodName: "RebootInstances",
			Handler:    _Ec2_RebootInstances_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x53, 0xdd, 0x8a, 0xd3, 0x40,
	0x14, 0x36, 0xcd, 0xba, 0x34, 0x27, 0xdb, 0x2e, 0xce, 0xba, 0x4b, 0x0d, 0x2e, 0xc4, 0xe8, 0x45,
	0x41, 0x48, 0xb5, 0x8a, 0x17, 0xeb, 0x95, 0x5d, 0x14, 0x7a, 0x65, 0x69, 0x61, 0x45, 0x11, 0x4a,
	0x9a, 0x9c, 0xd6, 0x40, 0x3a, 0x13, 0x67, 0x26, 0x8a, 0x77, 0x3e, 0x81, 0x78, 0xe5, 0x03, 0x78,
	0xe1, 0x13, 0xf9, 0x00, 0x3e, 0x8a, 0x99, 0x49, 0x5b, 0x9b, 0xb4, 0xb6, 0xb0, 0x77, 0x73, 0x7e,
	0xbe, 0x6f, 0xbe, 0xf3, 0xcd, 0x19, 0x38, 0x4e, 0x39, 0x93, 0xac, 0x13, 0x7c, 0x16, 0xbe, 0x3e,
	0x11, 0x3b, 0x3f, 0x8e, 0x43, 0x36, 0x9f, 0x07, 0x34, 0x72, 0xdc, 0x19, 0x63, 0xb3, 0x04, 0x3b,
	0xba, 0x34, 0xc9, 0xa6, 0x9d, 0x08, 0x45, 0xc8, 0xe3, 0x54, 0x32, 0x5e, 0xb4, 0x7b, 0x03, 0xb8,
	0x3d, 0x92, 0x2c, 0xed, 0x53, 0x21, 0x03, 0x1a, 0xa2, 0x18, 0xe2, 0xc7, 0x0c, 0x85, 0x24, 0x4d,
	0x38, 0x8c, 0xf8, 0x97, 0x61, 0x46, 0x5b, 0x86, 0x6b, 0xb4, 0xeb, 0xa4, 0x01, 0x37, 0xa7, 0x8c,
	0x87, 0xd8, 0xaa, 0xe9, 0xf0, 0x0e, 0xd8, 0x4b, 0x48, 0x3f, 0x12, 0x2d, 0xd3, 0x35, 0xdb, 0x56,
	0xef, 0xe0, 0xeb, 0xaf, 0x73, 0xc3, 0x1b, 0xc2, 0x49, 0x85, 0x51, 0x64, 0x89, 0x24, 0xcf, 0xe1,
	0x96, 0x4a, 0xa7, 0x31, 0x9d, 0xad, 0x4a, 0x39, 0xb7, 0xd9, 0xb6, 0xbb, 0xae, 0xbf, 0xa6, 0xd9,
	0x5f, 0x56, 0x47, 0x32, 0x90, 0x78, 0xf9, 0x21, 0xa0, 0x33, 0xf4, 0xde, 0xc1, 0x69, 0x1e, 0x72,
	0xb9, 0x21, 0xf3, 0x0c, 0x9a, 0x41, 0x14, 0xc5, 0x32, 0x66, 0x34, 0x48, 0xfa, 0x74, 0xca, 0xb4,
	0x5c, 0x6b, 0x4d, 0xfe, 0x5e, 0xbd, 0x0f, 0xa1, 0x51, 0xba, 0x92, 0x1c, 0xc1, 0x41, 0xc8, 0x22,
	0xd4, 0x4c, 0xa6, 0x8a, 0x68, 0x30, 0x2f, 0xe6, 0xb6, 0xbc, 0x6f, 0x06, 0x9c, 0x6c, 0x11, 0x48,
	0x08, 0x40, 0xbc, 0xe2, 0x5f, 0x68, 0x78, 0x04, 0x47, 0x61, 0xc6, 0x39, 0x52, 0xa9, 0x3b, 0x35,
	0x83, 0xdd, 0x75, 0xfe, 0x3f, 0x2c, 0x79, 0x0c, 0x8d, 0x94, 0xe3, 0xa7, 0x98, 0x65, 0xa2, 0x80,
	0x98, 0xfb, 0x20, 0xde, 0x48, 0xbd, 0x5f, 0xd9, 0x99, 0x7f, 0x76, 0xe7, 0xf9, 0x6b, 0xd9, 0x7d,
	0x09, 0x67, 0x43, 0x9c, 0x30, 0x26, 0xf7, 0xae, 0x45, 0xc5, 0xd7, 0xda, 0x9a, 0xaf, 0x0f, 0xe0,
	0x74, 0x83, 0x44, 0x4b, 0xb3, 0xc1, 0x44, 0xce, 0x0b, 0x93, 0xba, 0x3f, 0x6a, 0x79, 0x14, 0x76,
	0xc9, 0x5b, 0x68, 0x96, 0xe7, 0x20, 0x5e, 0x49, 0xe6, 0xd6, 0xe7, 0x77, 0xee, 0xed, 0xec, 0x51,
	0xb7, 0x79, 0x37, 0xc8, 0x15, 0x34, 0x4a, 0x0b, 0x49, 0xaa, 0xa8, 0xcd, 0xf5, 0x77, 0xdc, 0x5d,
	0x2d, 0x0b, 0xde, 0xf7, 0x70, 0x5c, 0x19, 0x90, 0xdc, 0x2f, 0xc1, 0xb6, 0x7b, 0xe8, 0x78, 0xbb,
	0x9b, 0x0a, 0xf6, 0x8b, 0xa7, 0x60, 0xc7, 0x62, 0xcc, 0x73, 0x4c, 0xcc, 0x31, 0x22, 0xe7, 0x7e,
	0xf1, 0x95, 0xfd, 0xe5, 0x57, 0xf6, 0x5f, 0xc5, 0x98, 0x44, 0xaf, 0x53, 0xb5, 0xfa, 0xa2, 0xf5,
	0xe7, 0xb7, 0x5a, 0x95, 0xfa, 0xc5, 0x33, 0xb0, 0x90, 0x66, 0xf3, 0xb1, 0x5a, 0xd9, 0x7c, 0xce,
	0x2a, 0xe6, 0x65, 0x5e, 0xbb, 0x0a, 0x92, 0x0c, 0x97, 0xb8, 0x9f, 0xdf, 0x15, 0xce, 0xea, 0xdd,
	0x85, 0x66, 0xc8, 0x7c, 0x96, 0x0a, 0x5c, 0x74, 0xf7, 0xea, 0x2f, 0xde, 0x8c, 0x06, 0xea, 0x34,
	0x30, 0x26, 0x87, 0x3a, 0xf5, 0xe4, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0xfb, 0xb7, 0x68,
	0x6d, 0x04, 0x00, 0x00,
}
